{"version":3,"file":"email.js","sources":["../../../src/validation/validators/email.ts"],"sourcesContent":["import { isEmpty, isNone } from '@ember/utils';\nimport { tKey } from 'ember-intl';\n\nimport BaseValidator from './base.ts';\nimport { regex as emailRegex } from '../../utils/email.ts';\n\nimport type { BaseOptions, ValidateFnResponse } from '../types';\n\nexport type EmailOptions = {\n  /**\n   * If `true`, the value can be an empty string, null, or undefined.\n   */\n  allowBlank?: boolean;\n  /**\n   * If provided, the value must not use any of the domains in the list.\n   *\n   * Note that subdomains are not supported.\n   */\n  invalidDomains?: string[];\n  /**\n   * If provided, the value must use one of the domains in the list.\n   *\n   * Note that subdomains are not supported.\n   */\n  validDomains?: string[];\n} & BaseOptions;\n\n/** TODO Add support for subdomains */\nexport default class EmailValidator<\n  Context extends object = Record<string, unknown>,\n> extends BaseValidator<string | null | undefined, Context, EmailOptions> {\n  validate(value: string | null | undefined, options: EmailOptions): ValidateFnResponse {\n    const { allowBlank, invalidDomains, validDomains } = options;\n\n    const key = tKey('nrg.validation.email.invalid');\n\n    if (isEmpty(value) || isNone(value)) {\n      if (allowBlank) {\n        return true;\n      }\n      return {\n        key,\n        value,\n      };\n    }\n\n    const matches = emailRegex.exec(value);\n    if (matches === null) {\n      return {\n        key,\n        value,\n      };\n    }\n    const [, , domainPart] = matches;\n\n    if (invalidDomains?.includes(domainPart!)) {\n      return {\n        key: tKey('nrg.validation.email.domain.invalid'),\n        value,\n        domains: this.listToString(invalidDomains),\n      };\n    }\n\n    if (validDomains && !validDomains.includes(domainPart!)) {\n      return {\n        key: tKey('nrg.validation.email.domain.valid'),\n        value,\n        domains: this.listToString(validDomains),\n      };\n    }\n\n    return true;\n  }\n\n  listToString(value: string[]): string {\n    return this.intl.formatList(value);\n  }\n}\n"],"names":["EmailValidator","BaseValidator","validate","value","options","allowBlank","invalidDomains","validDomains","key","tKey","isEmpty","isNone","matches","emailRegex","exec","domainPart","includes","domains","listToString","intl","formatList"],"mappings":";;;;;AA2BA;AACe,MAAMA,cAAc,SAEzBC,aAAa,CAAmD;AACxEC,EAAAA,QAAQA,CAACC,KAAgC,EAAEC,OAAqB,EAAsB;IACpF,MAAM;MAAEC,UAAU;MAAEC,cAAc;AAAEC,MAAAA;AAAa,KAAC,GAAGH,OAAO;AAE5D,IAAA,MAAMI,GAAG,GAAGC,IAAI,CAAC,8BAA8B,CAAC;IAEhD,IAAIC,OAAO,CAACP,KAAK,CAAC,IAAIQ,MAAM,CAACR,KAAK,CAAC,EAAE;AACnC,MAAA,IAAIE,UAAU,EAAE;AACd,QAAA,OAAO,IAAI;AACb,MAAA;MACA,OAAO;QACLG,GAAG;AACHL,QAAAA;OACD;AACH,IAAA;AAEA,IAAA,MAAMS,OAAO,GAAGC,KAAU,CAACC,IAAI,CAACX,KAAK,CAAC;IACtC,IAAIS,OAAO,KAAK,IAAI,EAAE;MACpB,OAAO;QACLJ,GAAG;AACHL,QAAAA;OACD;AACH,IAAA;AACA,IAAA,MAAM,IAAKY,UAAU,CAAC,GAAGH,OAAO;AAEhC,IAAA,IAAIN,cAAc,EAAEU,QAAQ,CAACD,UAAW,CAAC,EAAE;MACzC,OAAO;AACLP,QAAAA,GAAG,EAAEC,IAAI,CAAC,qCAAqC,CAAC;QAChDN,KAAK;AACLc,QAAAA,OAAO,EAAE,IAAI,CAACC,YAAY,CAACZ,cAAc;OAC1C;AACH,IAAA;IAEA,IAAIC,YAAY,IAAI,CAACA,YAAY,CAACS,QAAQ,CAACD,UAAW,CAAC,EAAE;MACvD,OAAO;AACLP,QAAAA,GAAG,EAAEC,IAAI,CAAC,mCAAmC,CAAC;QAC9CN,KAAK;AACLc,QAAAA,OAAO,EAAE,IAAI,CAACC,YAAY,CAACX,YAAY;OACxC;AACH,IAAA;AAEA,IAAA,OAAO,IAAI;AACb,EAAA;EAEAW,YAAYA,CAACf,KAAe,EAAU;AACpC,IAAA,OAAO,IAAI,CAACgB,IAAI,CAACC,UAAU,CAACjB,KAAK,CAAC;AACpC,EAAA;AACF;;;;"}