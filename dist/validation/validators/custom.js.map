{"version":3,"file":"custom.js","sources":["../../../src/validation/validators/custom.ts"],"sourcesContent":["import { assert } from '@ember/debug';\nimport { cached } from '@glimmer/tracking';\nimport { tKey } from 'ember-intl';\n\nimport BaseValidator from './base.ts';\n\nimport type { Binding } from '../../index.ts';\nimport type { BaseOptions, Computable, ValidateFnResponse, ValidationResult } from '../types';\n\ndeclare type ValidateFn<T, Context> = (\n  value: T,\n  options: CustomOptions<T, Context>,\n  context: Record<string, unknown>,\n) => ValidateFnResponse;\n\nexport type CustomOptions<T, Context> = {\n  /**\n   * The function to be called to validate. It should return a boolean or a\n   * response object.\n   */\n  validate: ValidateFn<T, Context>;\n} & BaseOptions;\n\nexport default class CustomValidator<\n  T,\n  Context extends object = Record<string, unknown>,\n> extends BaseValidator<T, Context, CustomOptions<T, Context>> {\n  constructor(\n    binding: Binding,\n    options: Computable<Context, CustomOptions<T, Context>>,\n    context?: Context,\n  ) {\n    super(binding, options, context);\n\n    const { validate } = options;\n\n    assert('CustomValidator requires a `validate` function to be provided', validate);\n  }\n\n  @cached\n  get result(): ValidationResult {\n    const { context, value } = this;\n    const { validate, ...options } = this.options;\n    const computedOptions = this.computeOptions(options as CustomOptions<T, Context>);\n\n    if (computedOptions.disabled) {\n      return { isValid: true };\n    }\n\n    let response = (validate as ValidateFn<T, Context>).apply(context, [\n      value,\n      computedOptions,\n      context as Record<string, unknown>,\n    ]);\n\n    const stringValue = String(value);\n    response = this.coalesceResponse(response, {\n      ...computedOptions,\n      // @ts-expect-error `value` is not an option defined on `CustomOptions`,\n      // but it is a valid option for the `coalesceResponse` method (which is\n      // is used for translations)\n      value: stringValue,\n    });\n    if (!response.isValid) {\n      response.message ??= this.intl.t(tKey('nrg.validation.custom.invalid'), {\n        value: stringValue,\n      });\n\n      delete computedOptions.key;\n    }\n\n    return this.coalesceResponse(response, computedOptions);\n  }\n\n  validate(): ValidateFnResponse {\n    assert('[BUG] The `validate` method should never be called directly');\n  }\n}\n"],"names":["CustomValidator","BaseValidator","constructor","binding","options","context","validate","assert","result","value","computedOptions","computeOptions","disabled","isValid","response","apply","stringValue","String","coalesceResponse","message","intl","t","tKey","key","n","prototype","cached"],"mappings":";;;;;;AAuBe,MAAMA,eAAe,SAG1BC,aAAa,CAAwC;AAC7DC,EAAAA,WAAWA,CACTC,OAAgB,EAChBC,OAAuD,EACvDC,OAAiB,EACjB;AACA,IAAA,KAAK,CAACF,OAAO,EAAEC,OAAO,EAAEC,OAAO,CAAC;IAEhC,MAAM;AAAEC,MAAAA;AAAS,KAAC,GAAGF,OAAO;AAE5BG,IAAAA,MAAM,CAAC,+DAA+D,EAAED,QAAQ,CAAC;AACnF,EAAA;EAEA,IACIE,MAAMA,GAAqB;IAC7B,MAAM;MAAEH,OAAO;AAAEI,MAAAA;AAAM,KAAC,GAAG,IAAI;IAC/B,MAAM;MAAEH,QAAQ;MAAE,GAAGF;KAAS,GAAG,IAAI,CAACA,OAAO;AAC7C,IAAA,MAAMM,eAAe,GAAG,IAAI,CAACC,cAAc,CAACP,OAAoC,CAAC;IAEjF,IAAIM,eAAe,CAACE,QAAQ,EAAE;MAC5B,OAAO;AAAEC,QAAAA,OAAO,EAAE;OAAM;AAC1B,IAAA;AAEA,IAAA,IAAIC,QAAQ,GAAIR,QAAQ,CAA4BS,KAAK,CAACV,OAAO,EAAE,CACjEI,KAAK,EACLC,eAAe,EACfL,OAAO,CACR,CAAC;AAEF,IAAA,MAAMW,WAAW,GAAGC,MAAM,CAACR,KAAK,CAAC;AACjCK,IAAAA,QAAQ,GAAG,IAAI,CAACI,gBAAgB,CAACJ,QAAQ,EAAE;AACzC,MAAA,GAAGJ,eAAe;AAClB;AACA;AACA;AACAD,MAAAA,KAAK,EAAEO;AACT,KAAC,CAAC;AACF,IAAA,IAAI,CAACF,QAAQ,CAACD,OAAO,EAAE;AACrBC,MAAAA,QAAQ,CAACK,OAAO,KAAK,IAAI,CAACC,IAAI,CAACC,CAAC,CAACC,IAAI,CAAC,+BAA+B,CAAC,EAAE;AACtEb,QAAAA,KAAK,EAAEO;AACT,OAAC,CAAC;MAEF,OAAON,eAAe,CAACa,GAAG;AAC5B,IAAA;AAEA,IAAA,OAAO,IAAI,CAACL,gBAAgB,CAACJ,QAAQ,EAAEJ,eAAe,CAAC;AACzD,EAAA;AAAC,EAAA;IAAAc,CAAA,CAAA,IAAA,CAAAC,SAAA,EAAA,QAAA,EAAA,CAjCAC,MAAM,CAAA,CAAA;AAAA;AAmCPpB,EAAAA,QAAQA,GAAuB;IAC7BC,MAAM,CAAC,6DAA6D,CAAC;AACvE,EAAA;AACF;;;;"}